//  gamma-analyzer-3d - 3d visualization of sessions generated by gamma-analyzer
//  Copyright (C) 2017  Dag Robole
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "spectrum.h"
#include <QJsonDocument>
#include <QJsonObject>
#include <QFile>

using namespace std;

namespace gamma
{

Spectrum::Spectrum(QString filename)
{
    loadFile(filename);
}

int Spectrum::channel(ChanListSize index) const
{
    if(index >= mChannels.size())
        throw RangeOutOfBounds("Spectrum::channel");

    return mChannels[index];
}

void Spectrum::loadFile(QString filename)
{
    QFile jsonFile(filename);
    if(!jsonFile.open(QFile::ReadOnly))
        throw UnableToLoadFile(filename);

    auto doc = QJsonDocument().fromJson(jsonFile.readAll());
    if(!doc.isObject())
        throw InvalidSpectrumFile(filename);

    auto obj = doc.object();
    if(!obj.contains("command"))
        throw InvalidSpectrumFile(filename);

    auto cmd = obj.value("command").toString();

    if(cmd != QStringLiteral("spectrum"))
        throw InvalidSpectrumFile(filename);

    if(!obj.contains("arguments"))
        throw InvalidSpectrumFile(filename);

    auto args = obj.value("arguments").toObject();

    mChannels.clear();
    mTotalCount = 0;

    if(args.contains("session_name"))
        mSessionName = args.value("session_name").toString();

    if(args.contains("session_index"))
        mSessionIndex = args.value("session_index").toInt();

    if(args.contains("iterations"))
        mSessionIterations = args.value("iterations").toInt();

    if(args.contains("preview"))
        mSessionPreview = args.value("preview").toInt();

    if(args.contains("delay"))
        mSessionDelay = args.value("delay").toDouble();

    if(args.contains("realtime"))
        mRealtime = args.value("realtime").toInt();

    if(args.contains("livetime"))
        mLivetime = args.value("livetime").toInt();

    if(args.contains("latitude_start"))
        mLatitudeStart = args.value("latitude_start").toDouble();

    if(args.contains("latitude_start_err"))
        mLatitudeStartErr = args.value("latitude_start_err").toDouble();

    if(args.contains("latitude_end"))
        mLatitudeEnd = args.value("latitude_end").toDouble();

    if(args.contains("latitude_end_err"))
        mLatitudeEndErr = args.value("latitude_end_err").toDouble();

    if(args.contains("longitude_start"))
        mLongitudeStart = args.value("longitude_start").toDouble();

    if(args.contains("longitude_start_err"))
        mLongitudeStartErr = args.value("longitude_start_err").toDouble();

    if(args.contains("longitude_end"))
        mLongitudeEnd = args.value("longitude_end").toDouble();

    if(args.contains("longitude_end_err"))
        mLongitudeEndErr = args.value("longitude_end_err").toDouble();

    if(args.contains("altitude_start"))
        mAltitudeStart = args.value("altitude_start").toDouble();

    if(args.contains("altitude_start_err"))
        mAltitudeStartErr = args.value("altitude_start_err").toDouble();

    if(args.contains("altitude_end"))
        mAltitudeEnd = args.value("altitude_end").toDouble();

    if(args.contains("altitude_end_err"))
        mAltitudeEndErr = args.value("altitude_end_err").toDouble();

    if(args.contains("gps_speed_start"))
        mGpsSpeedStart = args.value("gps_speed_start").toDouble();

    if(args.contains("gps_speed_start_err"))
        mGpsSpeedStartErr = args.value("gps_speed_start_err").toDouble();

    if(args.contains("gps_speed_end"))
        mGpsSpeedEnd = args.value("gps_speed_end").toDouble();

    if(args.contains("gps_speed_end_err"))
        mGpsSpeedEndErr = args.value("gps_speed_end_err").toDouble();

    if(args.contains("gps_time_start"))
        mGpsTimeStart = QDateTime::fromString(
                    args.value("gps_time_start").toString(),
                    Qt::DateFormat::ISODate);

    if(args.contains("gps_time_end"))
        mGpsTimeEnd = QDateTime::fromString(
                    args.value("gps_time_end").toString(),
                    Qt::DateFormat::ISODate);

    if(args.contains("channels"))
    {
        QString strChans = args.value("channels").toString();
        QStringList strChanList = strChans.split(' ',
                    QString::SplitBehavior::SkipEmptyParts);

        Q_FOREACH(QString chan, strChanList)
        {
            int count = chan.toInt();
            mChannels.push_back(count);
            mTotalCount += count;
        }
    }
}

} // namespace gamma
