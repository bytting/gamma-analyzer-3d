//  gamma-analyzer-3d - 3d visualization of sessions generated by gamma-analyzer
//  Copyright (C) 2017  Dag Robole
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "spectrum.h"
#include "detector.h"
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>

namespace Gamma
{

Spectrum::Spectrum(QString filename)
{
    loadFile(filename);
}

int Spectrum::channel(ChannelListSize index) const
{
    if(index >= mChannels.size())
        throw Exception_IndexOutOfBounds("Spectrum::channel");

    return mChannels[index];
}

void Spectrum::loadFile(QString filename)
{
    QFile jsonFile(filename);
    if(!jsonFile.open(QFile::ReadOnly))
        throw Exception_UnableToLoadFile(filename);

    auto doc = QJsonDocument().fromJson(jsonFile.readAll());
    if(!doc.isObject())
        throw Exception_InvalidSpectrumFile(filename);

    auto obj = doc.object();
    if(!obj.contains("command"))
        throw Exception_InvalidSpectrumFile(filename);

    auto cmd = obj.value("command").toString();

    if(cmd != QStringLiteral("spectrum"))
        throw Exception_InvalidSpectrumFile(filename);

    if(!obj.contains("arguments"))
        throw Exception_InvalidSpectrumFile(filename);

    auto args = obj.value("arguments").toObject();

    if(!args.contains("session_name"))
        throw Exception_MissingJsonValue("Spectrum:session_name");
    if(!args.contains("session_index"))
        throw Exception_MissingJsonValue("Spectrum:session_index");
    if(!args.contains("realtime"))
        throw Exception_MissingJsonValue("Spectrum:realtime");
    if(!args.contains("livetime"))
        throw Exception_MissingJsonValue("Spectrum:livetime");
    if(!args.contains("latitude_start"))
        throw Exception_MissingJsonValue("Spectrum:latitude_start");
    if(!args.contains("longitude_start"))
        throw Exception_MissingJsonValue("Spectrum:longitude_start");
    if(!args.contains("altitude_start"))
        throw Exception_MissingJsonValue("Spectrum:altitude_start");
    if(!args.contains("gps_time_start"))
        throw Exception_MissingJsonValue("Spectrum:gps_time_start");
    if(!args.contains("channels"))
        throw Exception_MissingJsonValue("Spectrum:channels");

    mSessionName = args.value("session_name").toString();
    mSessionIndex = args.value("session_index").toInt();
    mRealtime = args.value("realtime").toInt();
    mLivetime = args.value("livetime").toInt();
    coordinate.setLatitude(args.value("latitude_start").toDouble());
    coordinate.setLongitude(args.value("longitude_start").toDouble());
    coordinate.setAltitude(args.value("altitude_start").toDouble());
    mGpsTimeStart = QDateTime::fromString(
                args.value("gps_time_start").toString(),
                Qt::DateFormat::ISODate);

    auto strChans = args.value("channels").toString();
    auto strChanList = strChans.split(
                ' ', QString::SplitBehavior::SkipEmptyParts);

    mChannels.clear();

    for(const auto &chan : strChanList)
        mChannels.emplace_back(chan.toInt());

    position = coordinate.toCartesian();
}

static double GEValue(lua_State* L, double energy)
{
    double ge;

    lua_getglobal(L, "gevalue");
    lua_pushnumber(L, energy);
    lua_call(L, 1, 1);
    ge = (double)lua_tonumber(L, -1);
    lua_pop(L, 1);

    return ge;
}

void Spectrum::calculateDoserate(const Detector &detector, lua_State* L)
{
    mDoserate = 0.0;

    // Trim off discriminators
    int startChan = (int)((double)detector.numChannels() *
                          ((double)detector.LLD() / 100.0));
    int endChan = (int)((double)detector.numChannels() *
                        ((double)detector.ULD() / 100.0));
    if(endChan > detector.numChannels()) // FIXME: Can not exceed 100% atm
        endChan = detector.numChannels();

    // Accumulate doserates from each channel
    for (int i = startChan; i < endChan; i++)
    {
        double sec = (double)mLivetime / 1000000.0;
        double cps = mChannels[i] / sec;
        double E = detector.getEnergy(i);
        if (E < 0.05) // Energies below 0.05 are invalid
            continue;
        double GE = GEValue(L, E / 1000.0);
        double chanDose = GE * cps * 60.0;
        mDoserate += chanDose;
    }
}

} // namespace Gamma
