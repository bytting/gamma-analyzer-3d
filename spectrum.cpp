//  gamma-analyzer-3d - 3d visualization of sessions generated by gamma-analyzer
//  Copyright (C) 2017  Dag Robole
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "spectrum.h"
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>

using namespace std;

namespace Gamma
{

Spectrum::Spectrum(QString filename)
{
    loadFile(filename);
}

int Spectrum::channel(ChanListSize index) const
{
    if(index >= mChannels.size())
        throw GA::IndexOutOfBounds("Spectrum::channel");

    return mChannels[index];
}

void Spectrum::loadFile(QString filename)
{
    QFile jsonFile(filename);
    if(!jsonFile.open(QFile::ReadOnly))
        throw GA::UnableToLoadFile(filename);

    auto doc = QJsonDocument().fromJson(jsonFile.readAll());
    if(!doc.isObject())
        throw InvalidSpectrumFile(filename);

    auto obj = doc.object();
    if(!obj.contains("command"))
        throw InvalidSpectrumFile(filename);

    auto cmd = obj.value("command").toString();

    if(cmd != QStringLiteral("spectrum"))
        throw InvalidSpectrumFile(filename);

    if(!obj.contains("arguments"))
        throw InvalidSpectrumFile(filename);

    auto args = obj.value("arguments").toObject();

    mChannels.clear();

    if(args.contains("session_name"))
        mSessionName = args.value("session_name").toString();

    if(args.contains("session_index"))
        mSessionIndex = args.value("session_index").toInt();

    if(args.contains("realtime"))
        mRealtime = args.value("realtime").toInt();

    if(args.contains("livetime"))
        mLivetime = args.value("livetime").toInt();

    if(args.contains("latitude_start"))
        coordinate.setLatitude(args.value("latitude_start").toDouble());

    if(args.contains("longitude_start"))
        coordinate.setLongitude(args.value("longitude_start").toDouble());

    if(args.contains("altitude_start"))
        coordinate.setAltitude(args.value("altitude_start").toDouble());

    if(args.contains("gps_time_start"))
        mGpsTimeStart = QDateTime::fromString(
                    args.value("gps_time_start").toString(),
                    Qt::DateFormat::ISODate);

    if(args.contains("channels"))
    {
        auto strChans = args.value("channels").toString();
        auto strChanList = strChans.split(' ',
                    QString::SplitBehavior::SkipEmptyParts);

        for(auto chan : strChanList)
            mChannels.emplace_back(chan.toInt());
    }

    position = coordinate.toCartesian();
}

static double GEValue(lua_State* L, double energy)
{
    double ge;

    lua_getglobal(L, "gevalue");
    lua_pushnumber(L, energy);
    lua_call(L, 1, 1);
    ge = (double)lua_tonumber(L, -1);
    lua_pop(L, 1);

    return ge;
}

void Spectrum::calculateDoserate(const Detector &det, lua_State* L)
{
    mDoserate = 0.0;

    // Trim off discriminators
    int startChan = (int)((double)det.numChannels() *
                          ((double)det.LLD() / 100.0));
    int endChan = (int)((double)det.numChannels() *
                        ((double)det.ULD() / 100.0));
    if(endChan > det.numChannels()) // FIXME: Can not exceed 100% atm
        endChan = det.numChannels();

    // Accumulate doserates from each channel
    for (int i = startChan; i < endChan; i++)
    {
        float sec = (float)mLivetime / 1000000.0;
        float cps = mChannels[i] / sec;
        double E = det.getEnergy(i);
        if (E < 0.05) // Energies below 0.05 are invalid
            continue;
        double GE = GEValue(L, E / 1000.0);
        double chanDose = GE * cps * 60.0;
        mDoserate += chanDose;
    }
}

} // namespace Gamma
