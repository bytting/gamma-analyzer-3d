//  gamma-analyzer-3d - 3d visualization of sessions generated by gamma-analyzer
//  Copyright (C) 2017  Dag Robole
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "scene.h"
#include <QColor>
#include <Qt3DRender/QCamera>
#include <Qt3DRender/QCameraLens>
#include <Qt3DExtras/QOrbitCameraController>
#include <Qt3DRender/QMaterial>
#include <Qt3DExtras/QPhongMaterial>
#include <Qt3DExtras/QSphereMesh>
#include <Qt3DCore/QTransform>
#include <Qt3DRender/QAttribute>
#include <Qt3DRender/QBuffer>
#include <Qt3DRender/QGeometryRenderer>
#include <Qt3DRender/QGeometry>
#include <Qt3DExtras/QForwardRenderer>

Qt3DCore::QEntity* createScene(Qt3DExtras::Qt3DWindow *win)
{
    win->defaultFrameGraph()->setClearColor(QColor(27, 48, 46));

    Qt3DRender::QCamera *camera = win->camera();
    camera->lens()->setPerspectiveProjection(45.0f, 16.0f/9.0f, 0.1f, 10000.0f);
    camera->setUpVector(QVector3D(0.0, 1.0, 0.0));
    camera->setPosition(QVector3D(0, 20, 100.0f));
    camera->setViewCenter(QVector3D(0, 0, 0));

    Qt3DCore::QEntity *scene = new Qt3DCore::QEntity;
    Qt3DExtras::QOrbitCameraController *camController = new Qt3DExtras::QOrbitCameraController(scene);
    camController->setLinearSpeed(50.0f);
    camController->setLookSpeed(180.0f);
    camController->setCamera(camera);

    return scene;
}

Qt3DCore::QEntity* createGrid(unsigned int count,
                              float interval,
                              const QColor &color,
                              Qt3DCore::QEntity* parent)
{
    Qt3DCore::QEntity *entity = new Qt3DCore::QEntity(parent);
    Qt3DRender::QGeometryRenderer *mesh = new Qt3DRender::QGeometryRenderer(entity);
    Qt3DRender::QGeometry *geometry = new Qt3DRender::QGeometry(entity);
    Qt3DRender::QBuffer *dataBuffer = new Qt3DRender::QBuffer(Qt3DRender::QBuffer::VertexBuffer, entity);
    Qt3DRender::QAttribute *positionAttribute = new Qt3DRender::QAttribute(entity);
    Qt3DExtras::QPhongMaterial *material = new Qt3DExtras::QPhongMaterial(entity);
    Qt3DCore::QTransform *transform = new Qt3DCore::QTransform(entity);

    int halfCount = count / 2;
    int numVerts = (halfCount * 4) * 2;
    float halfLength = interval * (float)halfCount;

    QByteArray vertexBufferData;
    vertexBufferData.resize(numVerts * 3 * sizeof(float));
    float *ptr = reinterpret_cast<float*>(vertexBufferData.data());

    int i = 0;
    float x = -interval * (float)halfCount;
    for(; i < (numVerts * 3) / 2; i += 6)
    {
        ptr[i] = x;
        ptr[i+1] = 0.0f;
        ptr[i+2] = -halfLength;

        ptr[i+3] = x;
        ptr[i+4] = 0.0f;
        ptr[i+5] = halfLength - interval;

        x += interval;
    }

    float z = -interval * (float)halfCount;
    for(; i < numVerts * 3; i += 6)
    {
        ptr[i] = -halfLength;
        ptr[i+1] = 0.0f;
        ptr[i+2] = z;

        ptr[i+3] = halfLength - interval;
        ptr[i+4] = 0.0f;
        ptr[i+5] = z;

        z += interval;
    }

    dataBuffer->setData(vertexBufferData);

    positionAttribute->setAttributeType(Qt3DRender::QAttribute::VertexAttribute);
    positionAttribute->setBuffer(dataBuffer);
    positionAttribute->setVertexBaseType(Qt3DRender::QAttribute::Float);
    positionAttribute->setVertexSize(3);
    positionAttribute->setName(Qt3DRender::QAttribute::defaultPositionAttributeName());

    geometry->addAttribute(positionAttribute);

    mesh->setInstanceCount(1);
    mesh->setIndexOffset(0);
    mesh->setFirstInstance(0);
    mesh->setVertexCount(numVerts);
    mesh->setPrimitiveType(Qt3DRender::QGeometryRenderer::Lines);
    mesh->setGeometry(geometry);

    material->setAmbient(color);

    entity->addComponent(mesh);
    entity->addComponent(material);
    entity->addComponent(transform);

    return entity;
}

Qt3DCore::QEntity* createSpectrum(QString name,
                                  const QVector3D &pos,
                                  const QColor &color,
                                  Qt3DCore::QEntity *parent)
{
    Qt3DCore::QEntity *entity = new Qt3DCore::QEntity(parent);
    Qt3DExtras::QSphereMesh *mesh = new Qt3DExtras::QSphereMesh(entity);
    Qt3DCore::QTransform *transform = new Qt3DCore::QTransform(entity);
    Qt3DExtras::QPhongMaterial *material = new Qt3DExtras::QPhongMaterial(entity);

    entity->setObjectName(name);

    mesh->setRadius(0.8f);
    entity->addComponent(mesh);

    transform->setTranslation(pos);
    entity->addComponent(transform);

    material->setDiffuse(color);
    material->setSpecular(QColor(20, 20, 20));
    QColor ambientColor(color.red() - color.red() / 10,
                        color.green() - color.green() / 10,
                        color.blue() - color.blue() / 10);
    material->setAmbient(ambientColor);
    material->setShininess(3.0f);
    entity->addComponent(material);

    return entity;
}

Qt3DRender::QObjectPicker *createPicker(Qt3DCore::QEntity* parent)
{
    Qt3DRender::QObjectPicker *picker = new Qt3DRender::QObjectPicker(parent);
    picker->setHoverEnabled(false);
    picker->setEnabled(true);
    parent->addComponent(picker);
    return picker;
}
